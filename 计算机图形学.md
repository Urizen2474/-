# 计算机图形学

计算机图形和计算机视觉

图形生成图片中会有的模型（包括图片内的各种东西）

计算机视觉识别图片内的那些模型



![image-20220812145856550](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220812145856550.png)

## 1.线性代数

### 1.1向量

向量表示的一个方向和它的长度，单位向量则表示一个方向

两向量的和通过改变任一向量的长度，可以组成一个平面(张成空间)

当移除多个向量中的一个而不会改变张成空间的大小的时候，或者两向量共线，第n个向量刚好落在张成空间上面，则称这个向量为与其他向量线性相关（也可以理解为一个向量可以由其他向量单个表示或组合表示）



<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813143138108.png" alt="image-20220813143138108" style="zoom: 25%;" />

推导：向量空间的一组基（x,y,z）就是张成这个空间的一个线性无关的向量集

<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813145717050.png" alt="image-20220813145717050" style="zoom: 25%;" />

#### 1.1.1线性变换

线性变换需要遵守:
直线变换后仍然是直线

原点坐标不变

<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813150229017.png" alt="image-20220813150229017" style="zoom:25%;" />

线性变换效果等同于函数，在经过变换后，向量的值发生变化

理解线性变换：

例:

向量v = -1i + 2j  ----->变换后 v = -1* 变换后的i + 2*变换后的 j

因此只要获取到变换后的基变量(i,  j), 就可以获取到任意变量变换后的值

例：

向量 v = { x, y} = xi + yj

 

```
可以把变换后的i，j的向量表示结合在一起
例:
    2        4        2 4
i = 3    j = 8   ---> 3 8  的一个2×2矩阵   矩阵相乘就相当于
向量线性变换  x*i + y*j 

推导：                                        x
i, j可以代表向量的维度(两个就是2维的)，而一个竖直如  y的向量的维度由它的行数决定，所有这就是为什么矩阵相乘 左边矩阵的列数要等于右边矩阵的行数

```

![image-20220813152722080](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813152722080.png)



如果变换后的i，j是线性相关的，则整个空间都会被压缩到i，j组成的一条直线上面，

证实得到用原向量乘以这个i，j的矩阵，得到永远是i，j的等值变换

<font size=5>根据变化后的向量，和变换前的向量，反推变换矩阵</font>

![image-20220815092134844](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220815092134844.png)

取一个特殊的点，就可以求出变换矩阵

##### 1.1.1.1齐次坐标（仿射变换）

但是对于平移，不能够直接使用线性变换的矩阵表示形式

因此给向量增加一个维度

向量不会因为平移发生改变（向量代表一个方向），所以齐次坐标是0

![image-20220815093954213](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220815093954213.png)

2D的仿射变换最后一行必定是  0 0 1，对于其他的某些时候最后一行的元素有它自己的意义

因为齐次坐标的引进，可以推导出向量和点的加减的意义

![image-20220815094718133](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220815094718133.png)

点加点得到两个点中间的那个点

齐次坐标不是1或0的情况下的处理方法，都是一个点

![image-20220815095053119](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220815095053119.png)



变换一个负角度刚好是原角度的逆矩阵，刚好等于原矩阵的转置，且这个矩阵称为正交矩阵

![image-20220815140617416](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220815140617416.png)





##### 1.1.1.2复合线性变换

![image-20220813162132110](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813162132110.png)

经过多次变换的向量可以看成是每次变换的i，j矩阵相乘后乘以最初的向量

变换先后顺序从右向左

<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813162409942.png" alt="image-20220813162409942" style="zoom:25%;" />



<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813163640049.png" alt="image-20220813163640049" style="zoom:25%;" />

因此矩阵乘法其实就相当于是右边的矩阵相对于左边矩阵进行线性变换

2D向量的变换

![image-20220815102137044](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220815102137044.png)

### 1.2 3Dtransform

旋转：
<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816084521789.png" alt="image-20220816084521789" style="zoom: 33%;" /><img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816084949857.png" alt="image-20220816084949857" style="zoom: 25%;" />

绕那个轴旋转那个轴的坐标不变

绕y轴旋转sin会不同， 跟顺逆时针没关系,跟叉乘没关系,只是因为点的坐标为(x,y,z)这样的先后顺序

按xyz顺序排，xy=z，yz=x，zx=y=-xz，所以要加个负

**Rodrigues’ Rotation Formula**(罗德里格斯旋转公式)

[(32条消息) 罗德里格斯（Rodrigues）旋转公式及其推导_搁浅777的博客-CSDN博客_罗德里格斯旋转公式](https://blog.csdn.net/qq_36162042/article/details/115488168)

<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816091154599.png" alt="image-20220816091154599" style="zoom: 200%;" />

![image-20220816092012493](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816092012493.png)

![image-20220816092206568](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816092206568.png)

![image-20220816092225317](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816092225317.png)



#### 1.2.1罗德里格斯旋转方程

![image-20220816092839410](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816092839410.png)



![image-20220816093631519](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816093631519.png)

![image-20220816093702691](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816093702691.png)

![image-20220816093719795](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816093719795.png)

##### 1.2.1.1万向节死锁

欧拉旋转的一个弊端

因为欧拉旋转使得任意的旋转可以分解为绕三个旋转轴的旋转，因此如果中间那个角(假设xyz)，旋转了90度，那么不论其他两个角旋转了多少，中间那个角度对应的那个坐标轴会改变不了，就是说其他两个角的角度对它没有影响

<font size = 5>四元数</font>

用于解决万向节死锁

[(32条消息) 计算机图形学中的四元数(Quaternions)_搁浅777的博客-CSDN博客_quaternions](https://blog.csdn.net/qq_36162042/article/details/120631380)

![image-20220816110230124](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816110230124.png)

![image-20220816110348372](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816110348372.png)

四元数的定义和复数类似，区别在于，四元数一共有三个虚部，而复数只有一个。 所有四元数都可以下述形式：
q = a + b i + c j + d k , ( a , b , c , d ∈ R ) 

其中
i ^2 = j ^2 = k ^2 = i j k = − 1. 

![image-20220816110901837](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816110901837.png)

![image-20220816110959256](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220816110959256.png)

### 1.3Viewing Transform



#### 1.3.1视图变换

操作的是相机，因为相对相机运动，就可以相对于是物体移动

相机的位置，相机的正面朝向，相机的绕正面朝向的旋转

![image-20220819090824298](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819090824298.png)



约定相机不动，始终位于原点位置，且始终朝向-Z方向



<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819091307756.png" alt="image-20220819091307756" style="zoom:25%;" />

视图变换的坐标系可以对应到xyz坐标系

把相机朝向转向-Z，相机位置e移到原点，lookup转向Y，坐标轴X则是垂直于gt张成的平面

<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819091727634.png" alt="image-20220819091727634" style="zoom: 25%;" />





视图变换的旋转矩阵，先平移到原点，把t,g,e转向坐标轴很复杂，不如把坐标轴转向这些轴，因为旋转矩阵是正交矩阵，所以转置一下就是观测变换的旋转矩阵

![image-20220819094337979](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819094337979.png)

#### 1.3.2投影变换

Projection transform，模型和相机摆放好，有投影获得具体图片

正交投影(ortho)不会改变网格体的平行性，不会给予视觉上近大远小的感觉

透视投影(prespec)则相反

![image-20220819102305758](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819102305758.png)

![image-20220819102748909](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819102748909.png)

##### 1.3.2.1正交投影

简单的理解(只是用于理解)，把相机放在原点，朝向-Z，就可以直接把model的z轴直接去掉，就可以得到投影

![image-20220819103228479](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819103228479.png)

正式做法，获取立方体的所有的点在x,y,z上面的大小范围，先把立方体中心移到原点

![image-20220819103756251](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819103756251.png)



变换矩阵，把x,y,z缩放到2，相当于把整个模型压缩了

![image-20220819104409706](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819104409706.png)



##### 1.3.2.2透视投影

![image-20220819110554317](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819110554317.png)

可以将远平面挤压到和近平面一样的大小，然后再进行正交投影，近平面保持不变，并且远平面的中心点也保持不变(在挤压中)

<font color=red>如何挤压</font>

利用相似三角形

![image-20220819112130435](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819112130435.png)



因为仅考虑x,y的平面，z暂时还是未知，利用齐次坐标的性质，可以消掉z

![image-20220819112256929](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819112256929.png)

因此可以得出部分变换矩阵







![image-20220819112706231](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819112706231.png)



因此，对于任意一个近平面上面的点，它的z是不会变的(就是n)，所以对这个点的挤压始终都是它自身，因此也可以得到对于任意一个点，它的变换矩阵的第三行，即对于向量的z轴上的挤压，与它的x，y无关

![image-20220819124020734](F:\Typora\笔记\image-20220819124020734.png)



又由于远平面的中心点也是不变的，所以对近平面的z的结论也可以对应于远平面的点的z，f是远平面中心点的z

![image-20220819124900197](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819124900197.png)





然后通过这两个式子，就可以得到挤压矩阵的完整内容

![image-20220819130240209](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819130240209.png)





<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220819131432041.png" alt="image-20220819131432041" style="zoom:25%;" />









### 1.3矩阵



不支持交换律

![image-20220812202416021](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220812202416021.png)



被乘数的列数必须和乘数的行数相等  ，结果为行列数为被乘数的行数和乘数的列数

结果规则：
例：

（2，4）的26，取被乘数的2行作为向量（5，2），乘数的4列作为向量（4，3）

```
26 = （5，2）·（4，3）= 5*4 + 2*3
```

![image-20220812203649201](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220812203649201.png)

![image-20220812204025689](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220812204025689.png)



单位矩阵

![image-20220812204217383](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220812204217383.png)

向量的点积其实可以转换成矩阵



![image-20220812204544185](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220812204544185.png)



#### 







### 1.4行列式

在一个空间进行变换时，只要是线性变换，只要获得一个图形的缩放比例，就可以获得所有原有空间的图形的缩放比例

这个缩放比例叫做行列式，即图形缩放变换后的基向量组成的矩阵

行列式为负时，则成为改变了空间的走向（可以通过i，j互相的相对左右来判断，通常i在j的右边）

行列式的元素和变换矩阵一样，变换后的i，j的向量表示

![image-20220813190604312](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813190604312.png)

```
a和d乘积在b，c为0的情况下直接表示图形的行列式大小

bc表示图形（平行四边形）在对角线的方向上面变换了多少

```

<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813191242154.png" alt="image-20220813191242154" style="zoom:25%;" />



![image-20220813191657167](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813191657167.png)



### 1.5逆矩阵，零列式，零空间

```
例:
ax + by + cz = v1          a   b   z     x     v1
dx + ey + fz = v2  等价于   d   e   f  *  y   = v2 
gx + hy + iz = v3          g   h   i     z     v3   
因此将矩阵定位A 原向量x  得到向量 v
v = Ax  A即是对于向量x的线性变换 v是变换后得到的值
逆矩阵就是把v变换回x的线性变换

```

一个空间变换后，如果所有向量都成为线性相关（一条线或者一个平面），且变换后的空间的维度称为秩，一维的秩为1，二维的为2



![image-20220813200814023](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813200814023.png)

不论变换后是多少维都算在内

列空间就是A的列向量(想想i，j)，所张成的空间，所以更深层次的秩的定义是列空间的维度，当秩等于A的列向量数的时候，则成为满秩

<font size=6>零空间</font>

因为线性变换的原点是不会变的，但是当维度发生变化时，有一些向量会被压缩到原点，这些向量组成的空间成为零空间，这些向量成为零向量，并且这个方程组成为齐次线性方程组

<font color=red>在空间发生线性变换之前，与变换以后的空间正交的那些向量就是零向量</font>



<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813203118848.png" alt="image-20220813203118848" style="zoom:25%;" />

其实就是齐次的解系必然落在零空间里，零空间与变换矩阵垂直，非齐的解系目标向量要在变换矩阵内才有解，正好对应非齐和齐次的解的情况

<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220813203700294.png" alt="image-20220813203700294" style="zoom: 25%;" />

### 1.6非方阵（行列数不相等的矩阵）

降维，和升维的方法

```
例:
3 4 5      1 2
2 3 5  和  2 6     3×2代表的是三维向量的二维表示，即列向量的数量代表维度，  
           8 3     行向量的数量表示变换后的基向量的维度，等同于将一个三维向量映射到一个二维向量，其实它还是处于三维空间，只是向量表示变成了二维的
牢记矩阵的实质是用于向量变换的行列式
```

### 1.7点积

点积是一种特殊的将二维向量转成一位向量的线性变换，可以理解为一个向量转置成一个1×2的矩阵

<font size = 5>叉积</font>

叉积实际上是量向量围成的平行四边形的面积

<img src="C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220817220940499.png" alt="image-20220817220940499" style="zoom:25%;" />

叉积通常用来表示三维向量，两个三维向量的叉积等于一个长度等于两向量围成的平行四边形的面积，垂直于这个平行四边形





![image-20220817222209329](C:\Users\Urizen\AppData\Roaming\Typora\typora-user-images\image-20220817222209329.png)







### 1.8集合和映射

#### 1.3.1笛卡尔积

例:
a = {A , 0}  b = {1, 2 ,5} 

a×b = { (A , 1), (A , 2), (A , 5), (0, 1), (0, 2), (0, 5) }

b×a = {（1，A），（1，0），（2，A），（2，0），（5，A），（5，0）}

##### 1.3.1.1运算

1.对任意集合A，根据定义有

AxΦ =Φ , Φ xA=Φ

2.一般地说，笛卡尔积运算不满足交换律，即

AxB≠BxA（当A≠Φ ∧B≠Φ∧A≠B时）

3.笛卡尔积运算不满足结合律，即

(AxB)xC≠Ax(BxC)（当A≠Φ ∧B≠Φ∧C≠Φ时)

4.笛卡尔积运算对并和[交运算](https://baike.baidu.com/item/交运算)满足[分配律](https://baike.baidu.com/item/分配律)，即

Ax(B∪C)=(AxB)∪(AxC)

(B∪C)xA=(BxA)∪(CxA)

Ax(B∩C)=(AxB)∩(AxC)

(B∩C)xA=(BxA)∩(CxA)

#### 1.3.2基础概念

​       映射(**Mappings**),也称为函数(**Functions**),是数学和编程的基础，就像程序中的函数，数学中的映射接受一种类型的参数，并且映射到(返回到)特定类型的对象，在程序中,常常看到"类型"这个词语，在数学中, 它被定义为集合, 当有一个对象是集合的成员时，用符号 ϵ 表示，例如: a ϵ S，可以理解为"a是集合S的一个元素"，给定两个集合**A**和**B**，我们可以通过两个集合的笛卡尔积(**the Cartesian product of the two sets**)得出第三个集合,表示为**A** × **B**，这个集合**A** × **B** 由所有可能的有序对(a,b)组成,其中 a∈**A** && b∈**B**。作为速记，用符号A2 来代表**A** × **A** ,我们可以扩展笛卡儿积,用于从三个集合中创建一个包含所有可能的有序三元组的集合。对任意长度的任意多个集合的元组以此类推。

## 2配置环境

主要就是opencv和Eigen3

### 2.1opencv

[(33条消息) CMAKE Opencv配置_用户名溢出的博客-CSDN博客_cmake配置opencv](https://blog.csdn.net/bocai1215/article/details/124060798)

### 2.1Eigen3

要先到Eigen3的源代码下面执行

mkdir build 

cd build 

cmake ..

